title: js动画与css动画
date: 2015-09-08 14:51:26
tags:
---
CSS动画：
1、缺少独立的控制，如果把scale/rotation/position都塞进transform属性当中，不能够真正独立控制它们。如何用不同的时间和缓分别控制元素的rotation与scale，可能这个元素会不停的震荡，当然可以用不同的层来控制。

较新的 GSAP 同样是基于 JavaScript 的，但是毫不夸张的说它的性能相比于 jQuery 提升了近 20 倍。

CSS 动画“硬件加速”的原因：
1、GPU 的使用
>-GPU 在执行类似控制像素点的移动和应用变换矩阵和透明等方面都做了优化，因此现代浏览器会试着把这方面的任务从 CPU 转交给 GPU 来完成。
>-秘诀在于将应用动画的元素独立出来，建立一个自己的 GPU 层，因为只要一个层被创建，让 GPU 去移动那些像素点并把它们组合起来是很轻松的一件事。
>-不同于以每秒 60 次的速度计算每个像素点的位置，GPU 可以把大量的像素以层的方式储存，通过块像素操作来操作像素。
>**注：**GPU 是有图像存储空间限制的，因此将每个元素都转换为一个层是不合适的。一旦 GPU 的存储空间用完了，速度就会急剧降低。
通过 CSS 声明动画能够让浏览器决定哪个元素应该获得 GPU 层，并根据实际情况分配资源。

所以javascript动画也可以用一个 3D 特性的触发器（比如translate3d()或者matrix3d()）来让浏览器为这个元素开辟一个 GPU 层。

GPU 的加速，大多数是不能的，变换（比如 scale，rotation， translation 和 skew）和透明效果是直接受益的。

2、将计算转移给不同的线程
“硬件加速”的另一个方面是使用 CPU 的不同线程来进行和动画相关的计算。

>-只有与文档流无关的属性才能真正被移交给另一个线程，所以变换和透明度是首要受益者。
>-转移线程的过程中也是有开销的，大多数动画中，图像的渲染和文档的展现已经耗费了大多数的处理器资源（这还没有算上中间动画属性本身所耗费的资源）。
>-因此转移线程所带来的好处已经微乎其微了。比如，在一个动画中，98%的资源都用来计算图像的渲染和文档流的展现，只有2%的资源用来计算位置、旋转、透明度等属性，即使你将这部分的计算速度加快了十倍，整体带来的速度提升可能也只有1%而已。

GSAP

3、工作流
一些浏览器允许你在 CSS keyframes 动画中暂停，但最多也就是这样了。
不能在动画中寻找一个特定的时间点，不可能在半路反转动画，不可能变换时间尺度，不可能在特定的位置添加回调函数或是将他们绑定在一大堆回放事件上。

1、创建动画的过程中常常需要进行很多的试验，尤其是针对时间和缓动方式，seek()方法：
>-想象你创建了一个 60 秒长度的动画然后需要对最后 5 秒进行处理，为了看到编辑后的效果，你每次都要先等上 55 秒钟的时间才行。你可以使用这个方法直接跳过前面的时间，最后再移除这个方法，这样可以节省大量的时间。
>-创建基于 canvas 的对象以及第三方库对象的动画的场景越来越多，而 CSS 动画又只能以 DOM 元素为目标。

4、不适合使用css动画的情况
>-相对值：“再旋转 30 度”
>-嵌套：想象把一个动画嵌套在另一个同样可以被嵌套的动画之中，等等。设想控制主动画的时候所有的动画都能同步。这样的结构能促进生成模块化的代码，利于生产和维护。
>-进程报告：特定的动画结束了吗？如果没有，它现在处于整个过程中的什么位置。
>-特定删除：移除一个元素的动画，其他动画能正常进行。
>-代码简洁：CSS keyframes 即使不添加多余带前缀的属性，动画的代码也会非常冗长。

5、有限的动画效果(有待验证)
>-沿着曲线运动（比如贝塞尔曲线）
>-使用有趣的缓动效果，比如有弹性的，或是弹跳，或是粗糙的效果。虽然有cubic-bezier()这个选项，但它只允许两个控制点，因此功能也十分有限。
>-在 CSS keyframes 动画中针对不同的属性使用不同的缓动效果。缓动会应用到整个 CSS keyframes 上。
>-基于物理的动作。例如，有冲击效果的闪烁，或是恢复状态，就像这个Demo中的一样。
>-滚动位置的动画。
>-指定方向的旋转。比如沿最短方向旋转270度，或顺时针和逆时针。
>-元素属性的动画
